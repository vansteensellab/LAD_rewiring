##Various functions to analyze Lamina DamID data
##In particular to study differences in Lamina interactions between two conditions
##such as Laura's rewiring by CRISRPa and TALE activation of specific genes
##Bas van Steensel, version BvS181120-190514


#libraries required:
library(GenomicRanges)
library(data.table)


#superfast running sum calculator (from Elzo de Wit's domainogram function):
#x is numeric vector
#n is running window size
runsum2<-function(x,n=21){
  cumsum(x)->sum.v
  sum.v<-c(0,sum.v)
  diff(sum.v,n)
} #note: discards head and tail of size floor(n/2)!


#1. Function to read all files and simply add read counts of replicates for DamLam and Dam, respectively. Return as GRanges object
read.combine.DamID.replicates<-function(DamLam, Dam)
  #DamLam (char): vector of file paths to DamLam replicates
  #Dam (char): vector of file paths to matching Dam-only replicates
{if(length(DamLam) != length(Dam)){warning("warning: DamLam and Dam do not have the same number of replicates")}
  #combine reads from DamLam datasets:
  for (i in 1:length(DamLam))
   {data.df<-fread(cmd=paste("gunzip -c", DamLam[i]))
    names(data.df)<-c("seqnames","start","end","DamLam")
    print(paste("DamLam replicate", i, "total read count:", sum(data.df[,4])))
    if(i==1){DL<-data.df$DamLam}
    else{DL<-DL+data.df$DamLam}
   }
  for (i in 1:length(Dam))
   {data.df<-fread(cmd=paste("gunzip -c", Dam[i]))
    names(data.df)<-c("seqnames","start","end","Dam")
    print(paste("Dam replicate", i, "total read count:", sum(data.df[,4])))
    if(i==1){D<-data.df$Dam}
    else{D<-D+data.df$Dam}
  }
  data.df$Dam<-D; data.df$DamLam<-DL
  print("converting to GRanges object...")
  GR<-makeGRangesFromDataFrame(data.df,keep.extra.columns = T)
  print(paste("DamID data loaded and combined:", length(GR), "GATC fragments"))
  return(GR)
}

#2. Function to convert output of 1. into smoothed DamLam/Dam ratios. Return as GRanges object
smooth.DamID<-function(DamID.GR, ws=201, pseud=10)
  #returns GRanges object with smoothed log2(DamLam/Dam) as scores
  #note: it first does smoothing on Dam and DamLam each, then adds pseudocount to each, THEN calculates log2-ratio
  #DamID.GR: GRanges object with two metadata columns: Dam and DamLam. Generated by function read.combine.DamID.replicates()
  #ws (integer): window size for smoothing
  #pseud (integer): pseudocount to be added to each runsum2 window prior to calculating the DamLam/Dam ratio in that window
{stopifnot(ws%%2==1) #accept only odd window sizes
  #apply running window smoothing to Dam and DamLam each:
  Td<-runsum2(mcols(DamID.GR)$Dam, ws)
  Tdl<-runsum2(mcols(DamID.GR)$DamLam, ws) 
  #add padding at beginning and add to compensate for lost data
  pad<-floor(ws/2)
  Td<-c(rep(NA,pad), Td, rep(NA,pad))
  Tdl<-c(rep(NA,pad), Tdl, rep(NA,pad))
  #set elements to NA that have no reads in either Dam or DamLam:
  nd<-which(Td==0 & Tdl==0)
  Td[nd]<-NA; Tdl[nd]<-NA
  #add pseudocount to both channels: 
  Td<-Td+pseud
  Tdl<-Tdl+pseud
  #calculate logratios, normalize to mean:
  Tr<-log2(Tdl/Td)
  Tr<-Tr-mean(Tr, na.rm=TRUE)
  mcols(DamID.GR)$score<-Tr
  mcols(DamID.GR)<-mcols(DamID.GR)[,3]
  names(mcols(DamID.GR))<-"logratio"
  return(DamID.GR) #returns Granges object with smoothed log2(DamLam/Lam) as metadata
}


#3A. Domainogram calculation based on output .1
#note: This may not be statically correct, because the smoothed windows overlap
#in the original de Wit et al PLoS Genet 2008 paper this was not the case.
#Use at own risk! 
#See emp.domainogram() function below; which is an alternative to simply calculate genome-wide rankings of domain scores. 
#DOMAINOGRAM function:
domainogram.bvs <- function(damid.exp, damid.ctl, chrom, window.sizes=c(101), pseud=10, up=FALSE, logratios=FALSE)
  #input: 
  #damid.exp and damid.ctl: GRanges objects with DamID data as generated by read.combine.damid.replicates()
  #chrom: chromosome to be analyzed
  #window.sizes: vector of odd integers, window.sizes to be used for domainogram
  #pseud: pseudocount used in calculation of logratios
  #up: should be tested for signals in Exp going up compared to Ctl? Set to FALSE if testing for signals going down.
  #logratios: should calculations be done on DamID logratios (TRUE) or converted to linear ratios (FALSE)?
  #output: GRanges object with domainogram data.frame as metadata (accessible via mcols() function)
{stopifnot(sum(window.sizes%%2)==length(window.sizes))
  for(w.size in window.sizes)
  {cat("calculating window size", w.size, "\r")
    #first calculate (log)ratios using current window size
    Ctl<-smooth.DamID(damid.ctl, ws=w.size, pseud=pseud)
    Exp<-smooth.DamID(damid.exp, ws=w.size, pseud=pseud)
    #extract data vector:
    Ctl<-mcols(Ctl)$logratio
    Exp<-mcols(Exp)$logratio
    #convert to linspace if logratios==FALSE:
    if(logratios==FALSE) {Ctl<-2^Ctl; Exp<-2^Exp}
    #calculate difference and convert to quantiles:
    diff.damid <- Exp-Ctl
    if(up==FALSE) {diff.damid<- -diff.damid}
    q.vec <- (rank(diff.damid)-0.5)/length(diff.damid)
    #calculate p.values:
    run.q <- runsum2(log(q.vec[as.character(seqnames(damid.exp))==chrom]), n=w.size )
    chi.val <- -2*run.q
    comb.p <- pchisq(chi.val, df=w.size*2)
    comb.p <- -log10(comb.p)
    #make sure that comb.p is the same length again as input score vector:
    pad<-floor(w.size/2)
    comb.p<-c(rep(NA,pad), comb.p, rep(NA,pad))
    #put results into a matrix:
    if(w.size==window.sizes[1])
    {p.matrix<-comb.p}
    else
    {p.matrix<-cbind(p.matrix, comb.p)}
  } #end loop through window.sizes
  #return results as GRanges object:
  GR<-damid.ctl[seqnames(damid.ctl)==chrom] #create GRanges object for chrom only
  mcols(GR)<-p.matrix #add domainogram data as metadata
  names(mcols(GR))<-as.character(window.sizes)
  return(GR) 
}

#3B. Empirical domainogram calculation based on output .1
#this differs from the regular domainogram in that the null distribution is entirely empirical, 
#based on the entire genome.
#the returned values are simply the ranks of the differences in DamID values, for windows of the same size & genome-wide
emp.domainogram <- function(damid.exp, damid.ctl, chrom, window.sizes=c(101), pseud=10, up=FALSE, logratios=FALSE, loess.corr=NULL, baseline=0.3)
  #damid.exp and damid.ctl: GRanges objects with DamID data as generated by read.combine.damid.replicates()
  #chrom: chromosome to be analyzed
  #window.sizes: vector of odd integers, window.sizes to be used for domainogram
  #pseud: pseudocount used in calculation of logratios
  #up: should be tested for signals in Exp going up compared to Ctl? Set to FALSE if testing for signals going down.
  #logratios: should calculations be done on DamID logratios (TRUE) or converted to linear ratios (FALSE)?
  #loess.corr: a loess object to straighten the overall exp vs control relationship
  #baseline: if logratios==TRUE, the quantile below which data are not included in the rank scores.
  #-- this is because changes in DamID data for very low values (in log space) are essentially baseline fluctuations that are not relevant
  #output: GRanges object with domainogram data.frame as metadata (accessible via mcols() function)
{stopifnot(sum(window.sizes%%2)==length(window.sizes))
  for(w.size in window.sizes)
  {cat("calculating window size", w.size, "\r")
    #first calculate (log)ratios using current window size
    Ctl<-smooth.DamID(damid.ctl, ws=w.size, pseud=pseud)
    Exp<-smooth.DamID(damid.exp, ws=w.size, pseud=pseud)
    #extract data vector:
    Ctl<-mcols(Ctl)$logratio
    Exp<-mcols(Exp)$logratio
    #apply loess correction:
    if(!is.null(loess.corr)) {Exp <- Exp - predict(loess.corr, Ctl)}
    #convert to linspace if logratios==FALSE:
    if(logratios==FALSE) {Ctl<-2^Ctl; Exp<-2^Exp}
    #calculate difference :
    diff.damid <- Exp-Ctl
    if(up==FALSE) {diff.damid<- -diff.damid}
    #mask baseline effects if working in log space:
    #baseline is defined as all values below 0.3 quantile
    if(logratios==TRUE) {diff.damid<-ifelse(Exp< quantile(Exp, baseline, na.rm=TRUE) & Ctl< quantile(Ctl, baseline, na.rm=TRUE), NA, diff.damid)}
    #convert to quantiles
    q.vec <- rank(diff.damid, na.last="keep")/length(diff.damid[!is.na(diff.damid)])
    #calculate q.values:
    #put results into a matrix:
    if(w.size==window.sizes[1])
    {q.matrix<-q.vec[as.character(seqnames(damid.exp))==chrom]}
    else
    {q.matrix<-cbind(q.matrix, q.vec[as.character(seqnames(damid.exp))==chrom])}
  } #end loop through window.sizes
  #return results as GRanges object:
  GR<-damid.ctl[seqnames(damid.ctl)==chrom] #create GRanges object for chrom only
  mcols(GR)<-q.matrix #add domainogram data as metadata
  names(mcols(GR))<-as.character(window.sizes)
  return(GR) 
}



#4. Nice plot of outputs of #2.
plot.damid.pair<-function(damid.exp, damid.ctl, chrom, start, end, logratio=FALSE, fill=TRUE, ylim=NA, x.axis=TRUE, 
                          col.exp="darkred", col.ctl="navyblue", shade.exp="#FF000022", shade.ctl="#0000FF22", ...)
  #plots two DamID traces
  #damid.exp, damid.ctl: smoothed data of experimental and control sample(s), GRanges object from smooth.DamID() function
  #chrom: chromosome to be plotted
  #start: first bp to be plotted
  #end: last bp to be plotted
  #logratio: should data be plotted in log space?
  #fill: should space between exp and ctl curves be filled with color?
  #ylim: y-axis limits. Set to a single NA if it should be automatically determined 
  #col.exp: line color for experimental data
  #col.ctl: line color for control data
  #shade.exp: shade color between lines when exp>ctl
  #shade.ctl: shade color between lines when ctl>exp
{ #genome-wide quantiles :
  Q005<-quantile((mcols(damid.exp)$logratio + mcols(damid.ctl)$logratio)/2, 0.05, na.rm=TRUE)
  Q095<-quantile((mcols(damid.exp)$logratio + mcols(damid.ctl)$logratio)/2, 0.95, na.rm=TRUE)

  #extract relevant part of the data:
  Exp<-damid.exp[seqnames(damid.exp)==chrom & start(damid.exp)>=start & end(damid.exp)<=end]
  Ctl<-damid.ctl[seqnames(damid.ctl)==chrom & start(damid.ctl)>=start & end(damid.ctl)<=end]
  
  #if not logratio:
  if(logratio==FALSE) 
  {mcols(Exp)$logratio<-2^mcols(Exp)$logratio
  mcols(Ctl)$logratio<-2^mcols(Ctl)$logratio
  Q005<-2^Q005; Q095<-2^Q095
  }
  
  #make empty plot:
  if(is.na(ylim)) 
  {ylim<-range(Q005, Q095, mcols(Exp)$logratio,mcols(Ctl)$logratio, na.rm=TRUE)
   if(logratio==FALSE){ylim[1]<-0}
  }
  plot(start(Ctl), rep(0, length(Ctl)), type="n", ylim=ylim, xaxs="i", xaxt="n", ...)
  
  #add nice x-axis:
  if(x.axis==TRUE) {axis(side=1, axTicks(1), labels=round(axTicks(1)/1e6,1))}
  
  #fill in with polygons:
  if(fill==TRUE)
  {df<-data.frame(start=start(Ctl), E=mcols(Exp)$logratio, C=mcols(Ctl)$logratio)
  df$sign<-sign(df$E-df$C)
  df<-df[!is.na(df$sign),]
  df$switch<-c(0,diff(df$sign))/2
  df$segment<-cumsum(abs(df$switch))
  for(seg in unique(df$segment))
  {p<-which(df$segment==seg)
  xvals<-c(df$start[p], rev(df$start[p]))
  yvals<-c(df$E[p], rev(df$C[p]))
  shade<-ifelse(df$sign[p[1]]==1, shade.exp, shade.ctl)
  polygon(xvals, yvals, border=NA,col=shade)
  }
  }
  
  #add data lines:
  lines(start(Exp), mcols(Exp)$logratio, col=col.exp, lwd=2)
  lines(start(Ctl), mcols(Ctl)$logratio, col=col.ctl, lwd=2)
  
  #mark genome-wide quantiles :
  abline(h=c(Q005, Q095), lty=c("dotted","dashed"), col="grey", lwd=2)
  return(ylim) #return yaxis limits
}


#5. Nice plot of domainogram output of #3.
#PLOT DOMAINOGRAMS function:
plot.domainogram<-function(dg, start=1, end=Inf, col.exp="darkred", col.ctl="navyblue", x.axis.slack=0.04, x.axis=TRUE, ...)
  #input: 
  #dg: GRanges object of a single chromosome, with domainogram data as metadata, generated by domainogram.bvs() function
  #start: start chromosomal coordinate of plot (in bp)
  #end: end chromosomal coordindate of plot (in bp)
  #col.exp: plot color if exp>ctl
  #col.ctl: plot color if ctl>exp
  #x.axis.slack: how much slack should be added on each end of x-axis; 0.04 is same as regular plot function; 
  #    set to 0 if start and end are passed on from par("usr")
  #... par parameters to be passed on to plot function
{chrom<-unique(seqnames(dg))
stopifnot(length(chrom)==1)
color.fun1 <- colorRampPalette(c(col.exp,"white"))
color.fun2 <- colorRampPalette(c("white", col.ctl))
color.vec <- c(color.fun1(51),rep("#FFFFFF",899),color.fun2(51))
if(end == Inf){end<-max(end(dg))}
xslack<-(end-start)*x.axis.slack 
dgsub<-dg[start(dg)>=start-xslack & end(dg)<=end+xslack] #reduce dg to plotting region
xpos<-round((start(dgsub)+end(dgsub))/2)
print(range(xpos))
image(x=xpos, y=c(1:ncol(mcols(dgsub))), z=as.matrix(mcols(dgsub)), col=color.vec, 
      yaxt="n", xaxt="n", ...)
box()
#x-axis:
if(x.axis==TRUE){axis(side=1, axTicks(1), labels=round(axTicks(1)/1e6,1))}
#y-axis:
gatc2len<-mean(width(dgsub)) #average gatc fragment length
wsizes<-log10(as.integer(names(mcols(dgsub)))*gatc2len)
at<-pretty(wsizes, n=3) #log10 window sizes tick marks
#calculation y-axis coordinates of these tick marks
fullrange<-range(wsizes)
tpos<-((at-min(fullrange))*length(wsizes)/diff(fullrange))+0.5
axis(side=2, at=tpos, labels=at, ...)
}

#color key for domainogram:
plot.color.key.domainogram<-function(col.exp="darkred", col.ctl="navyblue", ...)
{CC<-c(0:1000)
 M<-cbind(CC,CC)
 color.fun1 <- colorRampPalette(c(col.exp,"white"))
 color.fun2 <- colorRampPalette(c("white", col.ctl))
 color.vec <- c(color.fun1(51),rep("#FFFFFF",899),color.fun2(51))
 image(M, col=color.vec, yaxt="n", xlab="genome-wide quantile", cex.lab=1.5, cex.axis=1.3, xpd=NA, mgp=c(2.5,1,0))
}



#6. Wrapper function to combine domainogram, two DamID tracks and gene annotation track in one nice plot:
full.rewiring.plot<-function(sDamid.exp, sDamid.ctl, data.summary, swinsize, dg, GOI, ann, mrg.left=1e6, mrg.right=1e6, logratio=FALSE, sgRNA=NA,
                             col.exp="darkred", col.ctl="navyblue", shade.exp="#FF000022", shade.ctl="#0000FF22", col.mrk="#55992F", ylab.main="DamID ratio")
{#determine gene and plotting coordinates:
  aw<-which(ann$gene %in% GOI)
  chrom<-unique(ann$chrom[aw])
  stopifnot(length(chrom)==1) #stop if gene appears to be on multiple chromosomes
  xrange<-c(min(ann$start[aw])-mrg.left, max(ann$stop[aw])+mrg.right)
  if(xrange[1]<1) {xrange[1]<-1}
  if(xrange[2]>max(end(dg))) {xrange[2]<-max(end(dg))}
  ann<-ann[ann$chrom==chrom,] #trim 
  #calculate smoothing window size in kb:
  swinsizekb<-round(mean(width(dg[start(dg)>=xrange[1] & end(dg)<=xrange[2]]))*swinsize/1000,0)
  
  ##layout parameters:
  m<-matrix(c(2,1,1,1,3)) #layout matrix
  layout(m)
  par(mar=c(0,0,0,0), mgp=c(1.8,0.5,0), oma=c(4,5,0.5,0.5), lend=1)
  
  #plot DamID tracks:
  plot.damid.pair(sDamid.exp, sDamid.ctl, chrom=chrom, start=xrange[1], end=xrange[2], logratio=logratio, x.axis=FALSE, 
                  cex.axis=1.5, col.exp=col.exp, col.ctl=col.ctl, shade.exp=shade.exp, shade.ctl=shade.ctl)
  #mark targeted loci:
  if(any(!is.na(sgRNA))){abline(v=sgRNA, col=col.mrk, lty="dotted", lwd=2)}
  if(logratio==TRUE) {mtext(bquote(log[2] ~"("~ .(ylab.main) ~")"), side=2, line=2.5, cex=1.3)}
  else {mtext(ylab.main, side=2, line=2.5, cex=1)}
  legend("topleft", horiz=TRUE, legend=data.summary, 
         lwd=3, col=c(col.ctl, col.exp), bty="n", cex=1.8)
  xlimf<-round(par("usr")[c(1,2)]) #actual full plotting window, to be passed on below.
  #plot domainogram above it:
  plot.domainogram(dg, start=xlimf[1], end=xlimf[2], las=1, x.axis=FALSE, cex.axis=1.5, col.exp=col.exp, col.ctl=col.ctl, x.axis.slack=0)
  mtext(expression("log"[10]*"(scale [bp])"), side=2, line=2.5, cex=1.3)
  
  #plot annotation using Sushi package functions:
  #first trim ann to only genes that overlap with xlimf:
  ann.gr<-makeGRangesFromDataFrame(ann)
  xlimf.gr<-makeGRangesFromDataFrame(data.frame(chrom=chrom, start=xlimf[1], stop=xlimf[2]))
  ovhits<-findOverlaps(xlimf.gr, ann.gr, select="all")
  ann.sub<-ann[to(ovhits),]
  #how many rows do we need (at least 2):
  ntracks<-max(countOverlaps(makeGRangesFromDataFrame(ann.sub),makeGRangesFromDataFrame(ann.sub), ignore.strand=TRUE)-1,2)
  print(ntracks)
  pcol<-ifelse(ann.sub$gene %in% GOI, "#55882F", "#666688CC") #gene colors
  pg<-plotGenes(geneinfo=ann.sub, chrom=chrom, chromstart=xlimf[1], chromend=xlimf[2], 
                col=pcol, plotgenetype="arrow", arrowlength=0.002, maxrows=ntracks, wigglefactor=0.004,
                fontsize=1.5, labelat="middle", labeloffset=0.4, labeltext=FALSE, scalefont=1)
  #mark targeted loci: 
  if(any(!is.na(sgRNA))){abline(v=sgRNA, col="#55992F", lty="dotted", lwd=2)}
  #label highlighted genes at their centers:
  gene.center<-c()
  for(i in 1:length(GOI))
  {aw<-which(ann$gene==GOI[i])
  gene.center[i]<-floor((min(ann$start[aw])+max(ann$stop[aw]))/2)
  }
  #because it is not predictable at which row the highlighted genes are plotted, add gene labels at all tracks:
  text(x=gene.center, y=c(1:ntracks), labels=GOI, col="#FEFEFE", adj=c(0.5, 0.5), cex=2)
  #add box around plot, yaxis label:
  box()
  mtext("Genes", side=2, line=2.5, cex=1.3)
  #x-axis ticks and labels:
  labelgenome( chrom=chrom, chromstart=xrange[1], chromend=xrange[2], n=3,scale="Mb", 
               cex.axis=1.6, chromcex=1.2, scalecex=1.2, scalefont=1, line=0, mgp=c(3,1,0), chromline=1, scaleline=1)
  #plot line to indicate smoothing running window size:
  lines(x=c(mean(gene.center)-1000*swinsizekb/2, mean(gene.center)+1000*swinsizekb/2), y=c(2.8, 2.8), col="#111111", lwd=6, xpd=NA)
  text(x=mean(gene.center)+1000*swinsizekb/2, y=2.8, labels=" running mean window size", col="#111111", adj=c(0, 0.4), cex=1.8, xpd=NA)
}



#7. Function to combine domainogram, RNAseq data and gene annotation track in one nice plot:
local.expression.plot<-function(RNAseq, dg, GOI, ann, mrg.left=1e6, mrg.right=1e6, logratio=FALSE, sgRNA=NA,
                             col.exp="darkred", col.ctl="navyblue", shade.exp="#FF000022", shade.ctl="#0000FF22", col.mrk="#55992F")
#RNAseq: data.frame, with at least columns: 
  #"start" (start coordinate of genes)
  #"stop" (stop coordinate of genes)
  #"chrom" (chromosome of genes)
  #"delta.express" (log2 ratio exp/ctl RNAseq)
  
  {#determine gene and plotting coordinates:
  aw<-which(ann$gene %in% GOI)
  chrom<-unique(ann$chrom[aw])
  stopifnot(length(chrom)==1) #stop if gene appears to be on multiple chromosomes
  xrange<-c(min(ann$start[aw])-mrg.left, max(ann$stop[aw])+mrg.right)
  
  #prepare RNAseq dataframe:
  RNAseq<-RNAseq[RNAseq$chrom==chrom,] #trim
  
  ##layout parameters:
  m<-matrix(c(2,1,1,3)) #layout matrix
  layout(m)
  par(mar=c(0,0,0,0), mgp=c(1.8,0.5,0), oma=c(4,5,0.5,0.5), lend=1)
  
  #plot Expression data:
  plot(RNAseq$start, RNAseq$delta.express, type="n", xlim=xrange, xaxt="n", xlab="", cex.axis=1.5)
  rect(xleft=RNAseq$start, ybottom=0, xright=RNAseq$stop, ytop=RNAseq$delta.express, col="#00000044", border="#00000044", 
       lwd=ifelse(RNAseq$stop-RNAseq$start < diff(xrange)/100 | abs(RNAseq$delta.express)<0.01 ,2,0))
  abline(h=0, col="darkgrey")
  mtext(expression("log"[2]*"(RNA-seq exp/ctrl)"), side=2, line=2.5, cex=1.3)
  
  #mark targeted loci:
  if(any(!is.na(sgRNA))){abline(v=sgRNA, col=col.mrk, lty="dotted", lwd=2)}
  xlimf<-round(par("usr")[c(1,2)]) #actual full plotting window, to be passed on below.
  #plot domainogram above it:
  plot.domainogram(dg, start=xrange[1], end=xrange[2], las=1, x.axis=FALSE, cex.axis=1.5, col.exp=col.exp, col.ctl=col.ctl)
  mtext(expression("log"[10]*"(scale [bp])"), side=2, line=2.5, cex=1.3)
  
  #plot annotation using Sushi package functions:
  #first trim ann to only genes that overlap with xlimf:
  ann.gr<-makeGRangesFromDataFrame(ann)
  xlimf.gr<-makeGRangesFromDataFrame(data.frame(chrom=chrom, start=xlimf[1], stop=xlimf[2]))
  ovhits<-findOverlaps(xlimf.gr, ann.gr, select="all")
  ann.sub<-ann[to(ovhits),]
  #how many rows do we need (at least 2):
  ntracks<-max(countOverlaps(makeGRangesFromDataFrame(ann.sub),makeGRangesFromDataFrame(ann.sub), ignore.strand=TRUE)-1,2)
  pcol<-ifelse(ann.sub$gene %in% GOI, "#55882F", "#666688CC") #gene colors
  pg<-plotGenes(geneinfo=ann.sub, chrom=chrom, chromstart=xlimf[1], chromend=xlimf[2], 
                col=pcol, plotgenetype="arrow", arrowlength=0.002, maxrows=ntracks, wigglefactor=0.004,
                fontsize=1.5, labelat="middle", labeloffset=0.4, labeltext=FALSE, scalefont=1)
  #mark targeted loci: 
  if(any(!is.na(sgRNA))){abline(v=sgRNA, col="#55992F", lty="dotted", lwd=2)}
  #label highlighted genes at their centers:
  gene.center<-c()
  for(i in 1:length(GOI))
  {aw<-which(ann.sub$gene==GOI[i])
  gene.center[i]<-floor((min(ann.sub$start[aw])+max(ann.sub$stop[aw]))/2)
  }
  #because it is not predictable at which row the highlighted genes are plotted, add labels at all tracks:
  text(x=gene.center, y=c(1:ntracks), labels=GOI, col="white", adj=c(0.5, 0.5), cex=2)
  #add box around plot, yaxis label:
  box()
  mtext("Genes", side=2, line=2.5, cex=1.3)
  #x-axis ticks and labels:
  labelgenome( chrom=chrom, chromstart=xrange[1], chromend=xrange[2], n=3,scale="Mb", 
               cex.axis=1.6, chromcex=1.2, scalecex=1.2, scalefont=1, line=0, mgp=c(3,1,0), chromline=1, scaleline=1)
 
  }
